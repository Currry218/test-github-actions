name: Build, Test, and Deploy

on:
  push:
    branches:
      - main

jobs:
  build-test-deploy:
    runs-on: ubuntu-latest

    steps:
    # Step 1: Checkout the code
    - name: Checkout Code
      uses: actions/checkout@v3

    # Step 2: Set up Node.js (if needed for building/testing)
    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '20'

    # Step 3: Install dependencies
    - name: Install Dependencies
      run: npm install

    # Step 4: Run Tests
    - name: Run Tests
      run: npm test

    # Step 5: Build the application
    - name: Build Application
      run: npm run build

    # Step 6: Log in to Container Registry (e.g., GitHub Packages)
    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v2
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    # Step 7: Build and Push Docker Image
    - name: Build and Push Docker Image
      run: |
        docker build -t ghcr.io/${{ github.repository }}/nestjs-app:latest .
        docker push ghcr.io/${{ github.repository }}/nestjs-app:latest

    # Step 8: Deploy Application
    - name: Deploy to Server
      run: |
        ssh user@your-server-ip <<EOF
          docker pull ghcr.io/${{ github.repository }}/nestjs-app:latest
          docker stop nestjs-app || true
          docker rm nestjs-app || true
          docker run -d --name nestjs-app -p 3000:3000 ghcr.io/${{ github.repository }}/nestjs-app:latest
        EOF
      env:
        SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

---

### Key Notes:
1. **Deploy Without Rebuilding**
   - If you skip the build steps (Steps 2â€“5), you can directly deploy by pulling the existing image from the container registry.

2. **Secrets**
   - Add `SSH_PRIVATE_KEY` to your repository secrets for secure server access.
   - Ensure you add credentials for your container registry (e.g., Docker Hub tokens, GitHub Packages).

3. **Customizations**
   - Update the Dockerfile in your project root to configure the container build process.
   - Modify deployment commands based on your server setup (e.g., Kubernetes, Docker Compose).

This setup ensures your `main` branch triggers the full build-test-deploy workflow, and you can redeploy existing images by skipping unnecessary steps. Let me know if you'd like help with specific configurations, such as a Kubernetes deployment!
